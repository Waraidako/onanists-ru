#### Арифметка в 8-разрядном процессоре

Отрицательные числа представляются в допкоде (two's complement) ака коды положительного и отрицательного числа дополняют друг друга до $2^n$
$A+[-A]_{доп}=2^n$
![Pasted image 20250305103815.png](%D0%9F%D0%B8%D0%BA%D1%87%D0%B8/%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D0%B8/Pasted%20image%2020250305103815.png)
Вычитание по сути - замена на сложение с дополнением вычитаемого
$$A-B=A+[-B]_{доп}$$ ^ Буквально начальная школа лмао
Сложение/вычитание чисел со знаком и без знака в процессоре работает одинаково, что там по операндам и результатам - на разработчике
Способы перевода из допкода в десятичную систему:

* Первод модуля + добавить минус
* Сумма степеней 2, где старший бит имеет вес $-2^n$

#### Сложение и вычитание 8-разрядных чисел на уровне процессора

![Pasted image 20250305104043.png](%D0%9F%D0%B8%D0%BA%D1%87%D0%B8/%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D0%B8/Pasted%20image%2020250305104043.png)

#### Флаги операций

Для чисел знаковых/беззнаковых:

* **Z (Zero)** - Результат = 0
* **C (Carry)** - Перенос при сложении, заём при вычитании
* **H (Half Carry)** - Межтетрадный перенос/заём
  Только для знаковых чисел:
* **N (Negative)** - Результат \< 0
* **V (Two's complement Overflow)** - Переполнение допкода
* **S (Sign)** - Знак результата $S=V\oplus N$
  Пример (ебал я его переписывать держи скрин):
  // Лол той же хернёй занимались лекцию назад, зачем ещё раз???
  ![Pasted image 20250305111302.png](%D0%9F%D0%B8%D0%BA%D1%87%D0%B8/%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D0%B8/Pasted%20image%2020250305111302.png)
  ![Pasted image 20250305105322.png](%D0%9F%D0%B8%D0%BA%D1%87%D0%B8/%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D0%B8/Pasted%20image%2020250305105322.png)
  ![Pasted image 20250305105339.png](%D0%9F%D0%B8%D0%BA%D1%87%D0%B8/%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D0%B8/Pasted%20image%2020250305105339.png)

#### Сложение/вычитание многобайтовых операндов

![Pasted image 20250305105919.png](%D0%9F%D0%B8%D0%BA%D1%87%D0%B8/%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D0%B8/Pasted%20image%2020250305105919.png)

#### Алгоритм умножения

````
; ch:cl = a*b
mul:
	clr cl ; C = 0
	clr ch
	ldi n,8
loop:
	clc
	sbrc b, 0
	add ch, a
	ror ch
	ror cl
	lsr b
	dec n
	brne loop
	ret
````

Алгоритм (идея считай та же что у умножения стобиком):
![Pasted image 20250305110153.png](%D0%9F%D0%B8%D0%BA%D1%87%D0%B8/%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D0%B8/Pasted%20image%2020250305110153.png)

#### Деление с восстановлением остатка

16-разрядное делимое, 8-разрядные делитель и частное
![Pasted image 20250305113125.png](%D0%9F%D0%B8%D0%BA%D1%87%D0%B8/%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D0%B8/Pasted%20image%2020250305113125.png)
$C=[AH,AL]/B$
Проверка на отсутствие переполнения результата: $B>AH$
Пример (я всё ещё ебал переписывать):
![Pasted image 20250305113415.png](%D0%9F%D0%B8%D0%BA%D1%87%D0%B8/%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D0%B8/Pasted%20image%2020250305113415.png)
![Pasted image 20250305113422.png](%D0%9F%D0%B8%D0%BA%D1%87%D0%B8/%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D0%B8/Pasted%20image%2020250305113422.png)
